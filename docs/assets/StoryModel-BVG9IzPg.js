import{T as b,S as g}from"./index-CbKvKYHm.js";const p="storyverse-db",h=1,c="stories",l="outbox-stories",u={_db:null,async _openDb(){return this._db?this._db:new Promise((e,a)=>{const o=indexedDB.open(p,h);o.onerror=t=>{console.error("[DB] Error opening IndexedDB:",t.target.error),a(new Error("Gagal membuka database IndexedDB."))},o.onsuccess=t=>{console.log("[DB] IndexedDB opened successfully."),this._db=t.target.result,e(this._db)},o.onupgradeneeded=t=>{console.log("[DB] Upgrading IndexedDB...");const s=t.target.result;s.objectStoreNames.contains(c)||(s.createObjectStore(c,{keyPath:"id"}),console.log(`[DB] Object store '${c}' created.`)),s.objectStoreNames.contains(l)||(s.createObjectStore(l,{autoIncrement:!0,keyPath:"tempId"}),console.log(`[DB] Object store '${l}' created.`))}})},async getAllStories(){const e=await this._openDb();return new Promise((a,o)=>{const n=e.transaction(c,"readonly").objectStore(c).getAll();n.onsuccess=()=>{console.log("[DB] Berhasil mengambil semua cerita dari IndexedDB:",n.result),a(n.result||[])},n.onerror=r=>{console.error("[DB] Error mengambil cerita dari IndexedDB:",r.target.error),o(new Error("Gagal mengambil cerita dari database."))}})},async putStories(e){if(!e||e.length===0)return Promise.resolve();const a=await this._openDb();return new Promise((o,t)=>{const s=a.transaction(c,"readwrite"),n=s.objectStore(c);let r=0;e.forEach(i=>{if(!i||typeof i.id>"u"){console.warn("[DB] Cerita tanpa ID valid dilewati:",i),r++,r===e.length&&o();return}const d=n.put(i);d.onsuccess=()=>{r++,r===e.length&&(console.log("[DB] Semua cerita berhasil disimpan/diperbarui di IndexedDB."),o())},d.onerror=m=>{r++,console.error(`[DB] Error menyimpan cerita ID ${i.id} ke IndexedDB:`,m.target.error),r===e.length&&(console.warn("[DB] Beberapa cerita mungkin gagal disimpan."),o())}}),s.oncomplete=()=>{},s.onerror=i=>{console.error("[DB] Error transaksi saat menyimpan cerita:",i.target.error),t(new Error("Gagal menyimpan cerita ke database."))}})},async getStoryById(e){const a=await this._openDb();return new Promise((o,t)=>{const r=a.transaction(c,"readonly").objectStore(c).get(e);r.onsuccess=()=>{o(r.result)},r.onerror=i=>{console.error(`[DB] Error mengambil cerita ID ${e}:`,i.target.error),t(new Error("Gagal mengambil cerita dari database."))}})},async deleteStory(e){const a=await this._openDb();return new Promise((o,t)=>{const r=a.transaction(c,"readwrite").objectStore(c).delete(e);r.onsuccess=()=>{console.log(`[DB] Cerita ID ${e} berhasil dihapus dari IndexedDB.`),o()},r.onerror=i=>{console.error(`[DB] Error menghapus cerita ID ${e}:`,i.target.error),t(new Error("Gagal menghapus cerita dari database."))}})},async addStoryToOutbox(e){const a=await this._openDb();return new Promise((o,t)=>{const n=a.transaction(l,"readwrite").objectStore(l),r={...e};r.tempId||(r.tempId=`offline-${Date.now()}-${Math.random().toString(36).substr(2,9)}`);const i=n.add(r);i.onsuccess=d=>{console.log("[DB] Cerita berhasil ditambahkan ke outbox IndexedDB:",d.target.result,r),o(d.target.result)},i.onerror=d=>{console.error("[DB] Error menambahkan cerita ke outbox:",d.target.error),t(new Error("Gagal menyimpan cerita ke outbox."))}})},async getAllOutboxStories(){const e=await this._openDb();return new Promise((a,o)=>{const n=e.transaction(l,"readonly").objectStore(l).getAll();n.onsuccess=()=>{console.log("[DB] Berhasil mengambil semua cerita dari outbox IndexedDB:",n.result),a(n.result||[])},n.onerror=r=>{console.error("[DB] Error mengambil cerita dari outbox:",r.target.error),o(new Error("Gagal mengambil cerita dari outbox."))}})},async deleteStoryFromOutbox(e){const a=await this._openDb();return new Promise((o,t)=>{const r=a.transaction(l,"readwrite").objectStore(l).delete(e);r.onsuccess=()=>{console.log(`[DB] Cerita dengan tempId ${e} berhasil dihapus dari outbox.`),o()},r.onerror=i=>{console.error(`[DB] Error menghapus cerita dari outbox (tempId: ${e}):`,i.target.error),t(new Error("Gagal menghapus cerita dari outbox."))}})}},D={_storiesCache:null,async fetchStories(e=!1){if(!e&&this._storiesCache)return this._storiesCache;const a=b.getToken();if(!a)throw new Error("Token tidak ditemukan. Silakan login kembali.");try{const o=await g.getStories(a);return this._storiesCache=o.sort((t,s)=>new Date(s.createdAt)-new Date(t.createdAt)),await u.putStories(this._storiesCache),this._storiesCache}catch(o){throw this._storiesCache=null,o}},async addNewStory(e,a,o,t){const s=b.getToken();if(!s)throw new Error("Sesi Anda telah berakhir. Silakan login kembali.");if(!e||!a)throw new Error("Deskripsi dan foto wajib diisi.");const n=new FormData;n.append("description",e),n.append("photo",a),o!=null&&t!=null&&(n.append("lat",parseFloat(o)),n.append("lon",parseFloat(t)));try{const r=await g.addStory(s,n);return this._storiesCache=null,r}catch(r){console.warn("Gagal unggah ke server, menyimpan ke outbox.",r);const i=await this._toBase64(a);throw await u.addStoryToOutbox({description:e,photoBase64:i,lat:o,lon:t,timestamp:Date.now()}),new Error("Cerita gagal diunggah, disimpan ke outbox offline.")}},async syncOutboxStories(){const e=b.getToken();if(!e)return{synced:0};const a=await u.getAllOutboxStories();if(!a.length)return{synced:0};let o=0;for(const t of a)try{const s=await this._base64ToBlob(t.photoBase64,"image/jpeg"),n=new File([s],"photo.jpg",{type:"image/jpeg"}),r=new FormData;r.append("description",t.description),r.append("photo",n),t.lat&&t.lon&&(r.append("lat",parseFloat(t.lat)),r.append("lon",parseFloat(t.lon))),await g.addStory(e,r),await u.deleteStoryFromOutbox(t.tempId),o++}catch(s){console.error("Gagal sync outbox:",s)}return this._storiesCache=null,{synced:o}},async fetchStoryDetail(e){const a=b.getToken();if(!a)throw new Error("Silakan login kembali.");return await g.getStoryDetail(a,e)},async getAllStoriesFromDb(){return await u.getAllStories()},async deleteStoryFromDb(e){await u.deleteStory(e)},async clearStoriesCacheFromDb(){await u.clearAllStories()},clearStoriesCache(){this._storiesCache=null},async _toBase64(e){return new Promise((a,o)=>{const t=new FileReader;t.onloadend=()=>a(t.result),t.onerror=o,t.readAsDataURL(e)})},async _base64ToBlob(e,a="image/jpeg"){return await(await fetch(e)).blob()}};export{D as default};
